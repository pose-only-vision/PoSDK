# Behavior Plugin (Behavior Plugin)

Behavior plugins are a special form of `Method`, typically used to encapsulate a series of method calls to form a specific functional module or workflow.

## Interface Introduction

```{important}
Behavior plugins must implement `Method`'s required interfaces:
- **`GetType()`**: Only **declare** in header file, automatically implemented by `REGISTRATION_PLUGIN` macro
- `Build()` or `Run()`: Implement specific algorithm logic. Usually behavior plugins only need to override `GetType()`, using the base class's provided `Build()` method is sufficient
```

Behavior plugins typically also override the following **optional interfaces**:

- **`virtual const std::string& GetMaterialType() const override;`**
  - Returns the main input data type expected by this behavior.
- **`virtual const std::string& GetProductType() const override;`**
  - Returns the final product data type generated by this behavior.
- **`virtual void SetOptionsFromConfigFile(const std::string& path, const std::string& file_type) override;`**
  - If needed, can customize loading logic for all method configurations of current behavior.

## Optional Derivation Methods

- **`Interface::Behavior`** (derived from `Method`)
  - Provides behavior plugin base interface.
- **`Interface::BehaviorPreset`** (derived from `Behavior`)
  - (Seems not fully implemented or used in current code, but conceptually exists) Can provide preset functionality similar to `MethodPreset`, such as automatic loading of behavior steps, managing sub-method configurations, etc.

## Example

```cpp
// my_behavior.hpp
#include <po_core.hpp>

namespace MyPlugin {
using namespace PoSDK;
using namespace Interface;

class MyBehavior : public BehaviorPreset { // Inherit BehaviorPreset

public:
    MyBehavior();
    // Only declare, automatically implemented by REGISTRATION_PLUGIN macro
    const std::string& GetType() const override;
    // Run() usually doesn't need to be overridden in BehaviorPreset, Build handles the flow
    // DataPtr Run() override; 
    const std::string& GetMaterialType() const override;
    const std::string& GetProductType() const override; 
};
} // namespace MyPlugin


// my_behavior.cpp
#include "my_behavior.hpp"

namespace MyPlugin {

MyBehavior::MyBehavior() {
    // Define sequential method steps included in behavior
    sequential_methods_ = {
        "method_feature_extraction", 
        "method_matching", 
        "method_track_building"
    };
    

}

// Don't need to manually implement GetType(), macro automatically generates

const std::string& MyBehavior::GetMaterialType() const {
    static const std::string type = "data_images"; // Assume input is images
    return type;
}

const std::string& MyBehavior::GetProductType() const {
    static const std::string type = "data_tracks"; // Assume output is tracks
    return type;
}

// Build method is provided by BehaviorPreset base class, it executes methods in sequential_methods_ order
// DataPtr MyBehavior::Build(const DataPtr& material_ptr) { ... }

} // namespace MyPlugin

// Plugin registration - GetType() automatically implemented by macro
REGISTRATION_PLUGIN(MyPlugin::MyBehavior, "my_behavior")
```

## Common Data Types

The input (`MaterialType`) and output (`ProductType`) of behavior plugins depend on the workflow they encapsulate.

## Behavior Parameter Configuration

- **Setup**: Behavior plugins themselves can load configurations through `SetOptionsFromConfigFile` (e.g., defining method call order).
- **Management**: Each method called internally by behavior plugins typically has its configuration managed and passed by the behavior plugin's `method_options_`.
- **Priority**: Behavior plugin configuration > Method plugin configuration
